<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Coding | rohan singh]]></title>
  <link href="http://www.rohanradio.com/blog/categories/coding/atom.xml" rel="self"/>
  <link href="http://www.rohanradio.com/"/>
  <updated>2012-03-17T16:38:14+01:00</updated>
  <id>http://www.rohanradio.com/</id>
  <author>
    <name><![CDATA[Rohan Singh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Isn't all coding about being too clever?]]></title>
    <link href="http://www.rohanradio.com/blog/2012/01/19/isnt-all-coding-about-being-too-clever/"/>
    <updated>2012-01-19T12:22:00+01:00</updated>
    <id>http://www.rohanradio.com/blog/2012/01/19/isnt-all-coding-about-being-too-clever</id>
    <content type="html"><![CDATA[<p>Every now and then I have a discussion or lecture with my roommate Chris, on some aspect of software
engineer, architecture, process management, or programming in general. His specialization is
psychology, so while this exercise can be cathartic, it's largely pointless. I've decided that it
might be more effective to write these things down and post them.</p>

<p>Today, prompted by a discussion on what I should name some new object, Chris asked:</p>

<blockquote><p>Isn't all coding about being too clever?</p></blockquote>

<p>I think that is a conception that many laypeople and beginning programmers have — that we should try
to be clever. Seasoned engineers will know that being clever can be one of the worst sins.</p>

<p>Here was my response, paraphrased:</p>

<blockquote><p>The goal is to write the minimal code that (a) gets the job done, (b) doesn't break, and (c) is
understandable and maintainable by other people.</p>

<p>"Clever" often meets the first requirement, can sometimes meet the second, and always fails
miserably at the third — which is actually the most important one. All things equal, I'd often
rather have a broken system that I can understand than a rat's nest of code that happens to work.</p></blockquote>

<p>That said, sometimes you do come across clever code that meets all of those requirements. These are
small masterpieces and works of art and should be regarded as such.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extreme Response Times]]></title>
    <link href="http://www.rohanradio.com/blog/2012/01/11/extreme-response-times/"/>
    <updated>2012-01-11T16:01:00+01:00</updated>
    <id>http://www.rohanradio.com/blog/2012/01/11/extreme-response-times</id>
    <content type="html"><![CDATA[<p>Looks like I have some serious optimization to do for the new stuff that I've
been building:</p>

<p><img src="/images/blog/extreme-response-times.png"></p>

<p>At least the latency seems pretty good?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Inner-Platform Effect]]></title>
    <link href="http://www.rohanradio.com/blog/2012/01/09/the-inner-platform-effect/"/>
    <updated>2012-01-09T20:45:00+01:00</updated>
    <id>http://www.rohanradio.com/blog/2012/01/09/the-inner-platform-effect</id>
    <content type="html"><![CDATA[<p>Today <a href="http://news.ycombinator.com/item?id=3442497">someone on Hacker News</a>
posted a link to the <a href="http://en.wikipedia.org/wiki/Inner-platform_effect">Wikipedia article on the inner-platform effect</a>,
which is "the tendency of software architects to create a system so customizable as to become a
replica, and often a poor replica, of the software development platform they are using."</p>

<p>One of my favorite parts of the article (emphasis mine):</p>

<blockquote><p>In the database world, developers are sometimes tempted to bypass the RDBMS, for
example by storing everything in one big table with two columns labelled key and
value. While this entity-attribute-value model allows the developer to break out
from the structure imposed by an SQL database, it loses out on all the benefits,
since all of the work that could be done efficiently by the RDBMS is forced onto
the application instead. Queries become much more convoluted, the indexes and
query optimizer can no longer work effectively, and data validity constraints
are not enforced. <strong>Such designs rarely make their way into real world production
systems, however, because performance tends to be little better than abysmal,
due to all the extra joins required.</strong></p></blockquote>

<p>Oh man, if only. I can think of at least <a href="http://www.magentocommerce.com/">one example</a> of a
a platform with this very problem — and with the associated horrible performance profile — that is
very widely deployed and used in production environments around the world. I'm sure you can think of
others.</p>
]]></content>
  </entry>
  
</feed>
